# [924. 尽量减少恶意软件的传播](https://leetcode-cn.com/problems/minimize-malware-spread)



## 题目描述

<!-- 这里写题目描述 -->

<p>在节点网络中，只有当 <code>graph[i][j] = 1</code>&nbsp;时，每个节点&nbsp;<code>i</code>&nbsp;能够直接连接到另一个节点 <code>j</code>。</p>

<p>一些节点&nbsp;<code>initial</code>&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>

<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>

<p>我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 <code>M(initial)</code>，&nbsp;则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。</p>

<p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后可能仍然因恶意软件传播而受到感染。</p>

<p>&nbsp;</p>

<ol>
</ol>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>输出：</strong>0
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>输出：</strong>0
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>输出：</strong>1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt; graph.length = graph[0].length &lt;= 300</code></li>
	<li><code>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt; graph.length</code></li>
	<li><code>0 &lt;= initial[i] &lt; graph.length</code></li>
</ul>


## 解法

<!-- 这里可写通用的实现逻辑 -->

<!-- tabs:start -->

### **Python3**

<!-- 这里可写当前语言的特殊实现逻辑 -->

```python
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def bfs(x):
            nonlocal n
            q = deque([x])
            vis = {x}
            while q:
                u = q.pop()
                for v in range(n):
                    if not graph[u][v] or v in vis:
                        continue
                    if v in initial:
                        return 0
                    q.append(v)
                    vis.add(v)
            return len(vis)

        n = len(graph)
        initial.sort()
        mx = ans = -1
        for x in initial:
            cur = bfs(x)
            if cur > mx:
                mx = cur
                ans = x
        return ans

```

### **Java**

<!-- 这里可写当前语言的特殊实现逻辑 -->

```java
class Solution {

    Set<Integer> ts = new HashSet<>();
    int n;

    public int bfs(int[][] graph, int x) {
        Deque<Integer> q = new ArrayDeque<>();
        q.add(x);
        Set<Integer> vis = new HashSet<>();
        vis.add(x);
        while (!q.isEmpty()) {
            int u = q.poll();
            for (int v = 0; v < n; v++) {
                if (graph[u][v] == 0 || vis.contains(v)) {
                    continue;
                }
                if (ts.contains(v)) {
                    return 0;
                }
                q.add(v);
                vis.add(v);
            }
        }
        return vis.size();
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        for (int v : initial) {
            ts.add(v);
        }
        Arrays.sort(initial);
        int ans = -1, mx = -1;
        for (int v : initial) {
            int cur = bfs(graph, v);
            if (cur > mx) {
                mx = cur;
                ans = v;
            }
        }
        return ans;
    }
}
```

### **...**

```

```

<!-- tabs:end -->
